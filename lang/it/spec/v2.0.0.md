---
layout: default
title: Semantic Versioning 2.0.0
---

Versionamento Semantico 2.0.0
=============================

Sommario
--------

Dato un numero di versione MAJOR.MINOR.PATCH, incrementa la:

1. versione MAJOR quando fai modifiche incompatibili alla API;
1. versione MINOR quando aggiungi funzionalità in modo retrocompatibile;
1. versione PATCH quando correggi bachi in modo retrocompatibile.

Sono disponibili etichette aggiuntive per pre-release e metadati di build come
estensioni al formato MAJOR.MINOR.PATCH.

Introduzione
------------

Nel mondo della gestione del software esiste un luogo terrificante chiamato
"inferno della dipendenza". Quanto più cresce il tuo sistema e quanti più 
pacchetti integri nel tuo software, tanto più facilmente ti ritroverai, un 
giorno, in questa fossa di disperazione.

Nei sistemi con molte dipendenze, rilasciare nuove versioni di pacchetti può 
diventare rapidamente un incubo. Se le specifiche di dipendenza sono troppo 
stringenti, sei a rischio di blocco di versione (l'impossibilità di aggiornare
un pacchetto senza dover rilasciare nuove versioni di ogni pacchetto 
dipendente). Se le dipendenze sono specificate in modo troppo lasco, sarai 
inevitabilmente bruciato da promisquità di versione (l'ipotizzare compatibilità 
con versioni future più di quanto sia ragionevole). L'inferno della dipendenza 
è dove sei quando blocco di versione e/o promisquità di versione ti impediscono 
di far avanzare il tuo progetto in modo semplice e sicuro.

Come soluzione a questo problema, propongo un semplice insieme di regole e 
requisiti che dettano come i numeri di versione sono assegnati ed incrementati.
Queste regole sono basate su, ma non necessariamente limitate a, diffuse
pratiche comuni adottate sia in software proprietario che open source.
Affinché questo sistema funzioni, hai prima bisogno di dichiarare una API 
pubblica. Quest'ultima può consistere di documentazione o essere imposta tramite
lo stesso codice. In ogni caso, è importante che tale API sia chiara e precisa. 
Dopo aver identificato la tua API pubblica, comunicane le modifiche con 
specifici incrementi del tuo numero di versione. Considera un formato di 
versione X.Y.Z (Major.Minor.Patch). La correzione di bachi, non influenzando
l'API, incrementa la versione Patch, aggiunte/modifiche all'API retrocompatibili
incrementano la versione Minor, e modifiche all'API non retrocompatibili 
incrementano la versione Major.

Chiamo questo sistema "Versionamento Semantico". Sotto questo schema, i numeri di 
versione ed il modo con cui essi cambiano comunicano significato relativamente
al codice sottostante e cosa è stato modificato da una versione alla successiva.


Specifica di Versionamento Semantico (SemVer)
---------------------------------------------

Le parole chiave "DEVE" ("MUST"), "NON DEVE" ("MUST NOT"), "REQUIRED", "SHALL", 
"SHALL NOT", "DOVREBBE" ("SHOULD"), "SHOULD NOT", "RECOMMENDED", "POTREBBE" ("POTREBBE"), 
e "OPTIONAL" in questo documento sono da interpretarsi come descritto nella 
[RFC 2119](http://tools.ietf.org/html/rfc2119).

1. Il software che usa Versionamento Semantico DEVE dichiarare una API pubblica. 
Questa API potrebbe essere dichiarata nel codice stesso oppure esistere
come documentazione rigorosa. Indipendentemente da come è dichiarata, dovrebbe
essere precisa a completa.

1. Un numero di versione normale DEVE essere nella forma X.Y.Z, dove X, Y, e Z 
sono interi non negativi, e NON DEVE contenere zeri iniziali. X è la versione
major, Y è la versione minor, e Z è la versione patch.
Ogni elemento DEVE incrementare come numero a sé. Per esempio: 
1.9.0 -> 1.10.0 -> 1.11.0.

1. Una volta che un pacchetto versionato è stato rilasciato, il contenuto di
quella versione NON DEVE essere modificato. Qualsiasi modifica DEVE essere
rilasciata come una nuova versione.

1. La versione Major zero (0.y.z) è per lo sviluppo iniziale. Qualunque cosa
può cambiare in qualsiasi istante. L'API pubblica non dovrebbe essere 
considerata stabile.

1. La versione 1.0.0 definisce l'API pubblica. Il modo in cui il numero di 
versione è incrementato dopo questo rilascio dipende da questa API pubblica
e da come quest'ultima cambia.

1. La versione Patch Z (x.y.Z | x > 0) DEVE essere incrementata solo se sono
introdotte correzioni retrocompatibili di bachi. Una correzione di un baco è
definita come una modifica interna che corregge un comportamento errato.

1. La versione Minor Y (x.Y.z | x > 0) DEVE essere incrementata se nell'API 
pubblica è introdotta una nuova funzionalità retrocompatibile. Essa DEVE essere
incrementata se qualsiasi funzionalità dell'API pubblica è marcata come 
deprecata. Essa POTREBBE essere incrementata se sono introdotti all'interno del 
codice privato nuove funzionalità o miglioramenti sostanziali. Essa POTREBBE 
includere modifiche di livello patch. La versione Patch DEVE essere
reimpostata a 0 quando la versione Minor è incrementata.

1. La versione Major X (X.y.z | X > 0) DEVE essere incrementata se nella API 
pubblica è introdotta qualsiasi modifica non retrocompatibile. Essa POTREBBE 
includere modifiche di livello minor e patch. Le versioni patch e minor DEVONO
essere reimpostate a 0 quando la versione major è incrementata.

1. Una versione di pre-rilascio POTREBBE essere indicata appendendo un trattino
e una serie di identificatori separati da un punto immediatamente successivi la
versione patch. Gli identificatori DEVONO essere composti solo da
alfanumerici ASCII e trattini. Gli identificatori NON DEVONO essere vuoti. Gli
identificatori numerici NON DEVONO includere zeri iniziali. Le versioni di
pre-rilascio hanno una precedenza inferiore rispetto alla normale versione
associata. Una versione di pre-rilascio indica che la versione è instabile
e potrebbe non soddisfare i requisiti di compatibilità intesi come indicato 
dalla versione normale ad essa associata. Esempi: 1.0.0-alpha, 1.0.0-alpha.1, 
1.0.0-0.3.7, 1.0.0-x.7.z.92.

1. Metadati di build POTREBBERO essere indicati appendendo un segno di addizione
e una serie di identificatori separati da un punto immediatamente successivi la
versione patch o pre-rilascio. Gli identificatori DEVONO essere composti solo da
alfanumerici ASCII e trattini. Gli identificatori NON DEVONO essere vuoti. I
metadati di build dovrebbero essere ignorati nella determinazione della 
precedenza delle versione. Perciò due versioni che differiscono solo per i 
metadati di build, hanno la stessa precedenza. Esempi: 1.0.0-alpha+001, 
1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.

1. La precedenza si riferisce a come le versioni sono confrontate l'una con
l'altra quando poste in relazione d'ordine. La precedenza DEVE essere calcolata 
separando gli identificatori nell'ordine seguente: major, minor, patch e 
pre-release (i metadati di build non compaiono nella precedenza). La precedenza 
è determinata dalla prima discrepanza quando si confrontano ognuno di tali 
identificatori da sinistra a destra come segue: le versioni major, minor e 
patch sono sempre confrontate numericamente. Esempio: 1.0.0 < 2.0.0 < 2.1.0 < 
2.1.1. 
Quando major, minor, e patch sono uguali, una versione di pre-rilascio ha una 
precedenza inferiore rispetto alla versione normale. Esempio: 1.0.0-alpha < 
1.0.0. 
La precedenza per due versioni di pre-rilascio con la stessa versione major, 
minor, e patch DEVE essere determinata confrontando ognuno degli identificatori
separati da punto da sinistra a destra finché si trova una discrepanza come 
segue: gli identificatori costituiti da sole cifre sono confrontati 
numericamente e gli identificatori con lettere o trattini sono confrontati
lessicamente secondo l'ordinamento ASCII. Gli identificatori numerici hanno
sempre una precedenza più bassa rispetto agli identificatori non numerici. 
Un insieme più grande di identificatori ha una precedenza superiore rispetto
ad un insieme più piccolo, se tutti quanti i precedenti identificatori sono 
uguali. Esempio: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta <
1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.

Perché usare il Versionamento Semantico?
----------------------------------------

Questa non è un'idea rivoluzionaria. Infatti, probabilmente fai già qualcosa di
simile a questo. Il problema è che quel "simile" non è abbastanza buono.
Senza la conformità a qualche tipo di specifica formale, i numeri di versione
sono essenzialmente inutili per la gestione delle dipendenze. Dando un nome
ed una chiara definizione alle idee sopra, diventa semplice comunicare le tue
intenzioni agli utenti del tuo software. Quando queste intenzioni sono chiare,
flessibili (ma non troppo flessibili) le specifiche di dipendenza possono
finalmente essere realizzate.

Un semplice esempio dimostrerà come il Versionamento Semantico può fare 
dell'inferno della dipendenza una cosa del passato. Considera una libreria
chiamata "CamionDeiPompieri". Essa richiede un pacchetto Semanticamente 
Versionato di nome "Scala". All'istante in cui è creato, Scala è alla versione 
3.1.0. Poiché CamionDeiPompieri utilizza alcune funzionalità che furono 
inizialmente introdotte in 3.1.0, puoi specificare con sicurezza la dipendenza 
da Scala come maggiore o uguale a 3.1.0 ma minore di 4.0.0. Ora, quando Scala 
versione 3.1.1 e 3.2.0 diventano disponibili, puoi rilasciarle al tuo sistema 
di gestione dei pacchetti e sapere che esse saranno compatibili con il software 
dipendente esistente.

In qualità di sviluppatore responsabile vorrai, naturalmente, verificare che
qualsiasi aggiornamento di pacchetto funzioni come descritto. Il mondo reale è
un luogo caotico; non possiamo farci nulla se non essere vigili. Ciò che puoi
fare è consentire a Versionamento Semantico di fornirti un modo sano di 
rilasciare ed aggiornare i pacchetti senza dover propagare le nuove versioni
ai pacchetti dipendenti, risparmiandoti tempo e fastidio.

Se tutto questo ti suona desiderabile, tutto ciò che ti serve fare per iniziare 
ad usare Versionamento Semantico è dichiarare che stai facendo così e poi 
seguire le regole. Rimanda a questo sito web dal tuo LEGGIMI (README) così altri
conosceranno le regole e potranno beneficiarne.


FAQ
---

### How should I deal with revisions in the 0.y.z initial development phase?

The simplest thing to do is start your initial development release at 0.1.0
and then increment the minor version for each subsequent release.

### How do I know when to release 1.0.0?

If your software is being used in production, it should probably already be
1.0.0. If you have a stable API on which users have come to depend, you should
be 1.0.0. If you're worrying a lot about backwards compatibility, you should
probably already be 1.0.0.

### Doesn't this discourage rapid development and fast iteration?

Major version zero is all about rapid development. If you're changing the API
every day you should either still be in version 0.y.z or on a separate
development branch working on the next major version.

### If even the tiniest backwards incompatible changes to the public API require a major version bump, won't I end up at version 42.0.0 very rapidly?

This is a question of responsible development and foresight. Incompatible
changes should not be introduced lightly to software that has a lot of
dependent code. The cost that must be incurred to upgrade can be significant.
Having to bump major versions to release incompatible changes means you'll
think through the impact of your changes, and evaluate the cost/benefit ratio
involved.

### Documenting the entire public API is too much work!

It is your responsibility as a professional developer to properly document
software that is intended for use by others. Managing software complexity is a
hugely important part of keeping a project efficient, and that's hard to do if
nobody knows how to use your software, or what methods are safe to call. In
the long run, Semantic Versioning, and the insistence on a well defined public
API can keep everyone and everything running smoothly.

### What do I do if I accidentally release a backwards incompatible change as a minor version?

As soon as you realize that you've broken the Semantic Versioning spec, fix
the problem and release a new minor version that corrects the problem and
restores backwards compatibility. Even under this circumstance, it is 
unacceptable to modify versioned releases. If it's appropriate,
document the offending version and inform your users of the problem so that
they are aware of the offending version.

### What should I do if I update my own dependencies without changing the public API?

That would be considered compatible since it does not affect the public API.
Software that explicitly depends on the same dependencies as your package
should have their own dependency specifications and the author will notice any
conflicts. Determining whether the change is a patch level or minor level
modification depends on whether you updated your dependencies in order to fix
a bug or introduce new functionality. I would usually expect additional code
for the latter instance, in which case it's obviously a minor level increment.

### What if I inadvertently alter the public API in a way that is not compliant with the version number change (i.e. the code incorrectly introduces a major breaking change in a patch release)

Use your best judgment. If you have a huge audience that will be drastically
impacted by changing the behavior back to what the public API intended, then
it may be best to perform a major version release, even though the fix could
strictly be considered a patch release. Remember, Semantic Versioning is all
about conveying meaning by how the version number changes. If these changes
are important to your users, use the version number to inform them.

### How should I handle deprecating functionality?

Deprecating existing functionality is a normal part of software development and
is often required to make forward progress. When you deprecate part of your
public API, you should do two things: (1) update your documentation to let
users know about the change, (2) issue a new minor release with the deprecation
in place. Before you completely remove the functionality in a new major release
there should be at least one minor release that contains the deprecation so
that users can smoothly transition to the new API.

### Does semver have a size limit on the version string?

No, but use good judgment. A 255 character version string is probably overkill, 
for example. Also, specific systems may impose their own limits on the size of 
the string.

About
-----

The Semantic Versioning specification is authored by [Tom
Preston-Werner](http://tom.preston-werner.com), inventor of Gravatars and
cofounder of GitHub.

If you'd like to leave feedback, please [open an issue on
GitHub](https://github.com/mojombo/semver/issues).


License
-------

Creative Commons - CC BY 3.0
http://creativecommons.org/licenses/by/3.0/
