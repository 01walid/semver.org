---
layout: default
title: Semantic Versioning 2.0.0
---

Semantic Versioning 2.0.0
==============================

Sommario
--------

Dato un numero di versione MAJOR.MINOR.PATCH, incrementa la:

1. versione MAJOR quando fai modifiche incompatibili alla API;
1. versione MINOR quando aggiungi funzionalità in modo retrocompatibile;
1. versione PATCH quando correggi bachi in modo retrocompatibile.

Sono disponibili etichette aggiuntive per pre-release e metadati di build come
estensioni al formato MAJOR.MINOR.PATCH.

Introduzione
------------

Nel mondo della gestione del software esiste un luogo terrificante chiamato
"inferno della dipendenza". Quanto più cresce il tuo sistema e quanti più 
pacchetti integri nel tuo software, tanto più facilmente ti ritroverai, un 
giorno, in questa fossa di disperazione.

Nei sistemi con molte dipendenze, rilasciare nuove versioni di pacchetti può 
diventare rapidamente un incubo. Se le specifiche di dipendenza sono troppo 
stringenti, sei a rischio di blocco di versione (l'impossibilità di aggiornare
un pacchetto senza dover rilasciare nuove versioni di ogni pacchetto 
dipendente). Se le dipendenze sono specificate in modo troppo lasco, sarai 
inevitabilmente bruciato da promisquità di versione (l'ipotizzare compatibilità 
con versioni future più di quanto sia ragionevole). L'inferno della dipendenza 
è dove sei quando blocco di versione e/o promisquità di versione ti impediscono 
di far avanzare il tuo progetto in modo semplice e sicuro.

Come soluzione a questo problema, propongo un semplice insieme di regole e 
requisiti che dettano come i numeri di versione sono assegnati ed incrementati.
Queste regole sono basate su, ma non necessariamente limitate a, diffuse
pratiche comuni adottate sia in software proprietario che open source.
Affinché questo sistema funzioni, hai prima bisogno di dichiarare una API 
pubblica. Quest'ultima può consistere di documentazione o essere imposta tramite
lo stesso codice. In ogni caso, è importante che tale API sia chiara e precisa. 
Dopo aver identificato la tua API pubblica, comunicane le modifiche con 
specifici incrementi del tuo numero di versione. Considera un formato di 
versione X.Y.Z (Major.Minor.Patch). La correzione di bachi, non influenzando
l'API, incrementa la versione Patch, aggiunte/modifiche all'API retrocompatibili
incrementano la versione Minor, e modifiche all'API non retrocompatibili 
incrementano la versione Major.

Chiamo questo sistema "Semantic Versioning." Sotto questo schema, i numeri di 
versione ed il modo con cui essi cambiano comunicano significato relativamente
al codice sottostante e cosa è stato modificato da una versione alla successiva.


Specifica di Semantic Versioning (SemVer)
-----------------------------------------

Le parole chiave "DEVE" ("MUST"), "NON DEVE" ("MUST NOT"), "REQUIRED", "SHALL", 
"SHALL NOT", "DOVREBBE" ("SHOULD"), "SHOULD NOT", "RECOMMENDED", "POTREBBE" ("POTREBBE"), 
e "OPTIONAL" in questo documento sono da interpretarsi come descritto nella 
[RFC 2119](http://tools.ietf.org/html/rfc2119).

1. Il software che usa Semantic Versioning DEVE dichiarare una API pubblica. 
Questa API potrebbe essere dichiarata nel codice stesso oppure esistere
strettamente in documentazione. Indipendentemente da come è dichiarata, dovrebbe
essere precisa a completa.

1. Un numero di versione normale DEVE essere nella forma X.Y.Z, dove X, Y, e Z 
sono interi non negativi, e NON DEVE contenere zeri iniziali. X è la versione
major, Y è la versione minor, e Z è la versione patch.
Ogni elemento DEVE incrementare numericamente. Per esempio: 
1.9.0 -> 1.10.0 -> 1.11.0.

1. Una volta che un pacchetto versionato è stato rilasciato, il contenuto di
quella versione NON DEVE essere modificato. Qualsiasi modifica DEVE essere
rilasciata come una nuova versione.

1. La versione Major zero (0.y.z) è per lo sviluppo iniziale. Qualunque cosa
può cambiare in qualsiasi istante. L'API pubblica non dovrebbe essere 
considerata stabile.

1. La versione 1.0.0 definisce l'API pubblica. Il modo in cui il numero di 
versione è incrementato dopo questo rilascio dipende da questa API pubblica
e da come quest'ultima cambia.

1. La versione Patch Z (x.y.Z | x > 0) DEVE essere incrementata solo se sono
introdotte correzioni retrocompatibili di bachi. Una correzione di un baco è
definita come una modifica interna che corregge un comportamento errato.

1. La versione Minor Y (x.Y.z | x > 0) DEVE essere incrementata se nell'API 
pubblica è introdotta una nuova funzionalità retrocompatibile. Essa DEVE essere
incrementata se qualsiasi funzionalità dell'API pubblica è marcata come 
deprecata. Essa POTREBBE essere incrementata se sono introdotti all'interno del 
codice privato nuove funzionalità o miglioramenti sostanziali. Essa POTREBBE 
includere modifiche di livello patch. La versione Patch DEVE essere
reimpostata a 0 quando la versione Minor è incrementata.

1. La versione Major X (X.y.z | X > 0) DEVE essere incrementata se nella API 
pubblica sono introdotte qualsiasi modifiche retrocompatibili. Essa POTREBBE 
includere modifiche di livello minor e patch. Le versioni patch e minor DEVONO
essere reimpostate a 0 quando la versione major è incrementata.

1. A pre-release version POTREBBE be denoted by appending a hyphen and a
series of dot separated identifiers immediately following the patch
version. Identifiers DEVE comprise only ASCII alphanumerics and hyphen
[0-9A-Za-z-]. Identifiers NON DEVE be empty. Numeric identifiers DEVE
NOT include leading zeroes. Pre-release versions have a lower
precedence than the associated normal version. A pre-release version
indicates that the version is unstable and might not satisfy the
intended compatibility requirements as denoted by its associated
normal version. Examples: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7,
1.0.0-x.7.z.92.

1. Build metadata POTREBBE be denoted by appending a plus sign and a series of dot 
separated identifiers immediately following the patch or pre-release version. 
Identifiers DEVE comprise only ASCII alphanumerics and hyphen [0-9A-Za-z-]. 
Identifiers NON DEVE be empty. Build metadata SHOULD be ignored when determining
version precedence. Thus two versions that differ only in the build metadata, 
have the same precedence. Examples: 1.0.0-alpha+001, 1.0.0+20130313144700, 
1.0.0-beta+exp.sha.5114f85.

1. Precedence refers to how versions are compared to each other when ordered.
Precedence DEVE be calculated by separating the version into major, minor, patch
and pre-release identifiers in that order (Build metadata does not figure 
into precedence). Precedence is determined by the first difference when
comparing each of these identifiers from left to right as follows: Major, minor,
and patch versions are always compared numerically. Example: 1.0.0 < 2.0.0 <
2.1.0 < 2.1.1. When major, minor, and patch are equal, a pre-release version has
lower precedence than a normal version. Example: 1.0.0-alpha < 1.0.0. Precedence
for two pre-release versions with the same major, minor, and patch version DEVE
be determined by comparing each dot separated identifier from left to right
until a difference is found as follows: identifiers consisting of only digits
are compared numerically and identifiers with letters or hyphens are compared
lexically in ASCII sort order. Numeric identifiers always have lower precedence
than non-numeric identifiers. A larger set of pre-release fields has a higher
precedence than a smaller set, if all of the preceding identifiers are equal.
Example: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta <
1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.

Why Use Semantic Versioning?
----------------------------

This is not a new or revolutionary idea. In fact, you probably do something
close to this already. The problem is that "close" isn't good enough. Without
compliance to some sort of formal specification, version numbers are
essentially useless for dependency management. By giving a name and clear
definition to the above ideas, it becomes easy to communicate your intentions
to the users of your software. Once these intentions are clear, flexible (but
not too flexible) dependency specifications can finally be made.

A simple example will demonstrate how Semantic Versioning can make dependency
hell a thing of the past. Consider a library called "Firetruck." It requires a
Semantically Versioned package named "Ladder." At the time that Firetruck is
created, Ladder is at version 3.1.0. Since Firetruck uses some functionality
that was first introduced in 3.1.0, you can safely specify the Ladder
dependency as greater than or equal to 3.1.0 but less than 4.0.0. Now, when
Ladder version 3.1.1 and 3.2.0 become available, you can release them to your
package management system and know that they will be compatible with existing
dependent software.

As a responsible developer you will, of course, want to verify that any
package upgrades function as advertised. The real world is a messy place;
there's nothing we can do about that but be vigilant. What you can do is let
Semantic Versioning provide you with a sane way to release and upgrade
packages without having to roll new versions of dependent packages, saving you
time and hassle.

If all of this sounds desirable, all you need to do to start using Semantic
Versioning is to declare that you are doing so and then follow the rules. Link
to this website from your README so others know the rules and can benefit from
them.


FAQ
---

### How should I deal with revisions in the 0.y.z initial development phase?

The simplest thing to do is start your initial development release at 0.1.0
and then increment the minor version for each subsequent release.

### How do I know when to release 1.0.0?

If your software is being used in production, it should probably already be
1.0.0. If you have a stable API on which users have come to depend, you should
be 1.0.0. If you're worrying a lot about backwards compatibility, you should
probably already be 1.0.0.

### Doesn't this discourage rapid development and fast iteration?

Major version zero is all about rapid development. If you're changing the API
every day you should either still be in version 0.y.z or on a separate
development branch working on the next major version.

### If even the tiniest backwards incompatible changes to the public API require a major version bump, won't I end up at version 42.0.0 very rapidly?

This is a question of responsible development and foresight. Incompatible
changes should not be introduced lightly to software that has a lot of
dependent code. The cost that must be incurred to upgrade can be significant.
Having to bump major versions to release incompatible changes means you'll
think through the impact of your changes, and evaluate the cost/benefit ratio
involved.

### Documenting the entire public API is too much work!

It is your responsibility as a professional developer to properly document
software that is intended for use by others. Managing software complexity is a
hugely important part of keeping a project efficient, and that's hard to do if
nobody knows how to use your software, or what methods are safe to call. In
the long run, Semantic Versioning, and the insistence on a well defined public
API can keep everyone and everything running smoothly.

### What do I do if I accidentally release a backwards incompatible change as a minor version?

As soon as you realize that you've broken the Semantic Versioning spec, fix
the problem and release a new minor version that corrects the problem and
restores backwards compatibility. Even under this circumstance, it is 
unacceptable to modify versioned releases. If it's appropriate,
document the offending version and inform your users of the problem so that
they are aware of the offending version.

### What should I do if I update my own dependencies without changing the public API?

That would be considered compatible since it does not affect the public API.
Software that explicitly depends on the same dependencies as your package
should have their own dependency specifications and the author will notice any
conflicts. Determining whether the change is a patch level or minor level
modification depends on whether you updated your dependencies in order to fix
a bug or introduce new functionality. I would usually expect additional code
for the latter instance, in which case it's obviously a minor level increment.

### What if I inadvertently alter the public API in a way that is not compliant with the version number change (i.e. the code incorrectly introduces a major breaking change in a patch release)

Use your best judgment. If you have a huge audience that will be drastically
impacted by changing the behavior back to what the public API intended, then
it may be best to perform a major version release, even though the fix could
strictly be considered a patch release. Remember, Semantic Versioning is all
about conveying meaning by how the version number changes. If these changes
are important to your users, use the version number to inform them.

### How should I handle deprecating functionality?

Deprecating existing functionality is a normal part of software development and
is often required to make forward progress. When you deprecate part of your
public API, you should do two things: (1) update your documentation to let
users know about the change, (2) issue a new minor release with the deprecation
in place. Before you completely remove the functionality in a new major release
there should be at least one minor release that contains the deprecation so
that users can smoothly transition to the new API.

### Does semver have a size limit on the version string?

No, but use good judgment. A 255 character version string is probably overkill, 
for example. Also, specific systems may impose their own limits on the size of 
the string.

About
-----

The Semantic Versioning specification is authored by [Tom
Preston-Werner](http://tom.preston-werner.com), inventor of Gravatars and
cofounder of GitHub.

If you'd like to leave feedback, please [open an issue on
GitHub](https://github.com/mojombo/semver/issues).


License
-------

Creative Commons - CC BY 3.0
http://creativecommons.org/licenses/by/3.0/
